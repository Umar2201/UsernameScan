// Server-only AI username generator using OpenRouter + Mistral 7B
// This file should only be imported in server context (route handlers, server actions)

const MODEL = "mistralai/mistral-7b-instruct";
const TIMEOUT_MS = 10000;

export interface AISuggestions {
    minimal: string[];
    professional: string[];
    niche: string[];
    creative: string[];
}

const MASTER_PROMPT = `You are an elite brand-naming AI with excellent taste.

Your job is to generate SUPERB, premium, brand-ready usernames that feel
human-crafted — not autogenerated.

The output must impress creators, founders, developers, and gamers.
If a name feels obvious, lazy, generic, or boring, it must be rejected.

These usernames must work across Tier-1 platforms:
Instagram, TikTok, YouTube, X (Twitter), Reddit, GitHub, Twitch, Steam.

━━━━━━━━━━━━━━━━━━━━━━
ABSOLUTE HARD RULES (NON-NEGOTIABLE)
━━━━━━━━━━━━━━━━━━━━━━
1. DO NOT generate low-effort usernames.
2. DO NOT generate names that are just:
   - base name + a single letter (X, Z, K, Y, etc.)
   - base name + obvious generic words like:
     tech, dev, media, digital, official, real, marketing, code
3. DO NOT use numbers unless they are part of a creative phonetic word.
4. DO NOT generate gamer-tag junk or spammy patterns.
5. DO NOT repeat the same construction pattern across names.
6. Every username must feel intentionally designed.
7. Do NOT repeat the same construction pattern across names.
8. Do NOT repeat the same word i need very unique names.


If any name violates these rules, it must be discarded internally.

━━━━━━━━━━━━━━━━━━━━━━
WHAT “EXCELLENT” LOOKS LIKE
━━━━━━━━━━━━━━━━━━━━━━
An excellent username:
- feels discovered, not generated
- sounds natural when spoken
- looks clean and confident on social platforms
- could realistically become a brand
- is memorable after one glance
- is usually 6-14 characters (flexible if strong)

━━━━━━━━━━━━━━━━━━━━━━
INPUT
━━━━━━━━━━━━━━━━━━━━━━
Base Name: {{base_name}}
Niche: {{niche}} (infer intelligently if missing)
Style Preference: {{style}} (infer intelligently if missing)

━━━━━━━━━━━━━━━━━━━━━━
CATEGORY DEFINITIONS
━━━━━━━━━━━━━━━━━━━━━━

Minimal Style:
- clean, elegant, identity-like
- subtle phonetic variations or refined forms
- calm, premium, personal-brand feeling

Professional Style:
- creator / founder / brand safe
- suitable for business, YouTube, GitHub, startups
- confident and modern, NOT corporate-generic

Niche Style:
- clearly adapted to the inferred niche
- shows intent (builder, creator, gamer, etc.)
- more specific and purposeful than Professional

Creative Style:
- internet-native but tasteful
- subtle twist, wordplay, or compound ideas
- never weird, never random, never messy

━━━━━━━━━━━━━━━━━━━━━━
FINAL SELF-CRITIQUE STEP (MANDATORY)
━━━━━━━━━━━━━━━━━━━━━━
Before outputting, internally review EVERY username.

Discard any name that:
- feels obvious
- feels auto-generated
- feels like base name + generic word
- would not impress a human designer or founder

If fewer than 5 truly strong usernames remain in any category,
regenerate internally until all 5 feel premium.

Only output usernames you would personally choose
for a serious, long-term brand.

━━━━━━━━━━━━━━━━━━━━━━
OUTPUT FORMAT (STRICT - DO NOT CHANGE)
━━━━━━━━━━━━━━━━━━━━━━

Minimal Style
- username
- username
- username
- username
- username

Professional Style
- username
- username
- username
- username
- username

Niche Style
- username
- username
- username
- username
- username

Creative Style
- username
- username
- username
- username
- username`;

function buildUserMessage(baseName: string, niche?: string, style?: string): string {
    let msg = `Base Name: ${baseName}`;
    if (niche) msg += `\nNiche: ${niche}`;
    if (style) msg += `\nPreferred Style: ${style}`;
    return msg;
}

function parseSuggestions(content: string): AISuggestions {
    const suggestions: AISuggestions = {
        minimal: [],
        professional: [],
        niche: [],
        creative: []
    };

    const lines = content.split('\n');
    let currentSection: keyof AISuggestions | null = null;

    for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed) continue;

        // Detect section headers (case-insensitive)
        if (trimmed.match(/^Minimal Style/i)) { currentSection = 'minimal'; continue; }
        if (trimmed.match(/^Professional Style/i)) { currentSection = 'professional'; continue; }
        if (trimmed.match(/^Niche Style/i)) { currentSection = 'niche'; continue; }
        if (trimmed.match(/^Creative Style/i)) { currentSection = 'creative'; continue; }

        // Parse usernames (lines starting with -)
        if (currentSection && trimmed.startsWith('-')) {
            const name = trimmed.replace(/^-\s*/, '').trim();
            // Take first part if there are spaces (robustness)
            const cleanName = name.split(' ')[0];
            if (cleanName) {
                suggestions[currentSection].push(cleanName);
            }
        }
    }

    return suggestions;
}

export async function generateAIUsernames(
    baseName: string,
    niche?: string,
    style?: string
): Promise<AISuggestions> {
    const apiKey = process.env.OPENROUTER_API_KEY;

    if (!apiKey) {
        throw new Error("OPENROUTER_API_KEY is not configured");
    }

    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), TIMEOUT_MS);

    try {
        const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
            method: "POST",
            headers: {
                "Authorization": `Bearer ${apiKey}`,
                "Content-Type": "application/json",
                "HTTP-Referer": "https://usernamescan.vercel.app",
                "X-Title": "UsernameScan",
            },
            body: JSON.stringify({
                model: MODEL,
                messages: [
                    { role: "system", content: MASTER_PROMPT },
                    { role: "user", content: buildUserMessage(baseName, niche, style) },
                ],
                temperature: 0.7,
                max_tokens: 800,
            }),
            signal: controller.signal,
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error?.message || `API request failed: ${response.status}`);
        }

        const data = await response.json();
        const content = data.choices?.[0]?.message?.content || "";

        if (!content) {
            throw new Error("No content in API response");
        }

        return parseSuggestions(content);
    } catch (error) {
        clearTimeout(timeoutId);

        if (error instanceof Error && error.name === "AbortError") {
            throw new Error("Request timed out");
        }
        throw error;
    }
}
